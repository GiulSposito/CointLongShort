---
title: "Operando Long-Short usando Cointegração em R"
author: Giuliano Sposito
output:
  html_document:
    keep_md: yes
    code_folding: hide
  pdf_document: default
---

Operações Long-Short por Cointegração é uma estratégia de investimento em ativos que consistes em ...este notebook refaz o passo-a-passo nas análises estatísticas necessárias para esse tipo de operação

<!--more-->

## Introdução

Operações Long-Short por Cointegração... 

## Análise de Cointegração usando R

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
# setup
library(knitr)

# default behavior for chunks
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(cache = TRUE)
```

Este notebook tem o objetivo de reproduzir o passo-a-passo para detectar e avaliar pares de ativos [cointegrados](https://en.wikipedia.org/wiki/Cointegration) mostrado no [blog do Dr. Nickel](https://drnickel.wordpress.com/2015/04/03/long-short-atraves-de-cointegracao-parte-3/). 
Muitos dos textos explicativos aqui foram retirados (ou fortemente baseados) na série de posts sobre Cointegração explicando o processo de análise, portando vale a pena ler a série toda, bem mais detalhada e com ótimas referências:

1. [Long-Short através de Cointegração – Parte 1](https://drnickel.wordpress.com/2015/03/15/long-short-atraves-de-cointegracao-parte-1/)
1. [Long-Short através de Cointegração – Parte 2](https://drnickel.wordpress.com/2015/03/15/long-short-atraves-de-cointegracao-parte-2/)
1. [Long-Short através de Cointegração – Parte 3](https://drnickel.wordpress.com/2015/04/03/long-short-atraves-de-cointegracao-parte-3/)
1. [Long-Short através de Cointegração – Parte 4](https://drnickel.wordpress.com/2016/11/05/long-short-atraves-de-cointegracao-parte-4/)

### Dataset:  QUAL3 e RENT3

No poste ele faz faz uma análise dos ativos [**QUAL3** - QUALICORP ON](https://www.infomoney.com.br/qualicorp-qual3) e [**RENT3** - Localiza ON](https://www.infomoney.com.br/localiza-rent3) usando uma [planilha excel](https://drnickel.files.wordpress.com/2015/04/exemplos-cointegracao-qual3_rent32.xlsx), neste notebook refaço o procedimento usando R. Para garantir que os resultados obtidos em ambas sejam os mesmos usaremos exatamente os mesmo dados que constam na planilha.


![Cotações de QUAL3 e RENT3 no Excel](./img/excel_data.png)


Após a importação, obtemos:

```{r loadData, message=FALSE, warning=FALSE}
# data handlers
library(tidyverse)
library(lubridate)

# table formatting
library(kableExtra)

# loading data
library(xlsx)
xls <- read.xlsx("./exemplos-cointegracao-qual3_rent32.xlsx",2) 

# what we get?
xls %>%
  select(-`NA..4`) %>%  # this column crashs the table format
  head(10) %>% 
  kable(caption="Excel Importado") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

Como o Excel não está adequadamente formatado (há células colapsadas e colunas vazias entre os dados) e acabamos com um dado importado muito sujo, há necessidade de limpar, *tipar* e arrumar 
[(data tidying)](http://r4ds.had.co.nz/tidy.html), deixando-os simples de manipular.

```{r tidyingTickers}

# cleaning up (tidying)
# first get QUAL3
xls %>% 
  as.tibble() %>% 
  select( ref.date = Data, price.close=QUAL3 ) %>% 
  filter( complete.cases(.) ) %>% 
  mutate( ticker="QUAL3",
          price.close = as.numeric(as.character(price.close)) ) -> qual


# and then RENT3
xls %>% 
  as.tibble() %>% 
  select( ref.date = Data, price.close=RENT3 ) %>% 
  filter( complete.cases(.) ) %>% 
  mutate( ticker="RENT3",
          price.close = as.numeric(as.character(price.close)) ) -> rent

# bind them
df.tickers = bind_rows(qual,rent)

# much better
df.tickers %>% 
  arrange(ref.date) %>% 
  head(10) %>% 
  kable(caption="Dados 'Tidy' ") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

```


```{r cleanMemory, echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
rm(xls, qual, rent);gc()
```

Com o dataset mais organizado, vamos visualizar os preços dos ativos importados.

```{r tickersPlot}
## plot as line
library(ggplot2)
ggplot(df.tickers,aes(x=ref.date, y=price.close, color=ticker)) +
  geom_line(size=1) + theme_light()

```

## Séries Não Estacionárias

O primeiro passo é testar se cada uma das séries é não-estacionária, aplicando o teste [Dickey-Fuller](https://en.wikipedia.org/wiki/Dickey%E2%80%93Fuller_test) em cada série de preços. A hipótese nula do teste DF é que a série é não-estacionária, portanto neste primeiro teste queremos que a hipótese nula não seja rejeitada.

Para aplicar o teste DF, precisamos primeiro calcular os valores defasados (`lags`) de cada série e o `delta` (diferença entre o preço do dia e o preço do dia anterior) e após isto fazer regressão do `delta` em função do `lag`:

$$\Delta P_{t} = \alpha + \beta P_{t-1} + \epsilon$$

Após fazer a regressão, o valor chave a ser usado para determinar se a série é não estacionária é o [`t-statistic`](https://dss.princeton.edu/online_help/analysis/interpreting_regression.htm) do coeficente $\beta$ obtido, que é o valor do coeficiente dividido pelo desvio padrão. Pode ser pensado como uma medida da precisão com que o coeficiente de regressão é medido. Se um coeficiente é grande comparado ao seu erro padrão, provavelmente é diferente de 0. Esse valor então é confrontado contra uma tabela de referência, que determinará se a série é estacionária ou não. 

![Dickey-Fuller Table](./img/dickey-fuller-table.png)

O valor de referência é sensível ao número de pontos usados na regressão. Assim sendo, vamos fazer o fit da regressão linear e obter os valores de referência desta regressão

```{r DickeyFuller}

# fit a LM model with one day delta price
fitLagModel <- function(dtf){

  # pega os datasets de precos de um ticker
  dtf %>% 
    select( price.close ) %>% # so interessa o preco de fechametno
    mutate( price.lag = lag(price.close,1), # cria um "lag" de um dia
            price.delta = price.close - price.lag ) %>%  # delta entre fechamento e lag
    filter( complete.cases(.) ) %>% # elimina valores vazios
    lm( price.lag ~ price.delta, . ) %>% # fita o modelo
    return()
}

## testes de series estacionarias
## para cada ticker fita o modelo linear
## tidyfica alguns parametros do modelo
library(broom)
df.tickers %>%
  group_by(ticker) %>%
  nest() %>% 
  mutate ( lagModel = map(data, fitLagModel), 
           lm.coefs  = map(lagModel,tidy),  
           lm.glance = map(lagModel, glance),
           lm.anova  = map(lagModel, anova),
           lm.anova  = map(lm.anova, tidy)) -> stat.test
```

Então para cada um dos ticker, temos um dataset com as cotações, o modelo fitado, dados dos coeficientes, análise de variação e qualidade do fit. Vamos olhar o valor para cada uma das séries.


```{r fitQuality}
stat.test %>% 
  select(ticker, lm.glance) %>% 
  unnest(lm.glance) %>% 
  kable(caption = "Qualidade da regressão") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

```{r fitAnova}
stat.test %>% 
  select(ticker, lm.anova) %>% 
  unnest(lm.anova) %>% 
  kable(caption= "Análise de variação") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

```

```{r fitCoefs}
stat.test %>% 
  select(ticker, lm.coefs) %>% 
  unnest(lm.coefs) %>% 
  kable(caption="Coeficientes da regressão") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

Então comparamos os `t-statistics` obtido para cada um dos coeficientes.

```{r tstats}

stat.test %>% 
  select(ticker, lm.coefs) %>% 
  unnest(lm.coefs) %>% 
  select(ticker, term, estimate, statistic, p.value) %>%
  filter( term!="(Intercept)" ) %>% 
  select(-term) %>% 
  inner_join( count(df.tickers , ticker), by="ticker") -> coefs

coefs %>% 
  kable(caption="Coeficientes da regressão") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

```

Para QUAL3 encontramos o valor de **`r round(coefs[coefs$ticker=="QUAL3", "statistic"],3)`** e para RENT3 encontramos **`r round(coefs[coefs$ticker=="RENT3", "statistic"],3)`** para ~500 amostras. Ambos os valores estão abaixo (em módulo) dos valores de referência na tabela Dickey-Fuller (**-2.87**), mostrando que ambas as séries são "não-estacionárias".

## Teste de Cointegração (metodologia de Engle-Granger)

A metodologia de Engle-Granger consiste em dois passos: primeiro fazemos uma regressão linear de uma série temporal contra a outra. Em seguida, aplicamos um teste de estacionariedade (como por exemplo o teste de Dickey-Fuller) nos resíduos desta regressão. Se os resíduos forem estacionários, isto significa que encontramos a combinação linear tal que as duas séries são cointegradas.

Então vamos avaliar a combinação linear entre QUAL3 e RENT3

```{r plotCombinacao}
df.tickers %>% 
  spread(key=ticker, value=price.close) %>% 
  ggplot(aes(x=RENT3, y=QUAL3)) +
    geom_point(size=2, alpha=.5) + theme_light()

```


```{r cointegradion}
# faz a composicao para detectar a cointegração
# fitando um modelo de um ativo contra outro
df.tickers %>% 
  spread(key=ticker, value=price.close) %>%
  lm(QUAL3 ~ RENT3, .) -> coint

# avalia valores obtidos no modelo
coint %>%
  glance() %>% 
  kable(caption = "Qualidade da regressão") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

```{r cointAnova}
coint %>%
  anova() %>%
  tidy() %>%  
  kable(caption = "Análise de Variacao") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

```

```{r cointCoefs}
coint %>% 
  tidy() %>%  
  kable(caption = "Coeficientes da Regressao") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

E aplicar teste DF nos resíduos da regressão.

```{r cointDF}
# monta um dataset para avaliar os residuos
df.tickers %>%
  filter( ticker=="QUAL3" ) %>% 
  select(ticker, ref.date, price.close) %>% 
  bind_cols(
    tibble(
      predicted = coint$fitted.values,
      residuals = coint$residuals
    )    
  ) %>% 
  mutate( lagRes = lag(residuals,1),
          deltaRes = residuals - lagRes ) -> coint.ds

coint.ds %>% 
  head(10) %>% 
  kable(caption = "Preparacao dos Resíduos para fazer teste Dickey-Fuller") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

```

```{r resDF}
# fit dos residuos
coint.ds %>% 
  lm(lagRes ~ deltaRes, .) -> coint.lm
```


```{r resGlance}
# avalia valores obtidos no modelo
coint.lm %>%
  glance() %>% 
  kable(caption = "Qualidade da regressão") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

```{r resAnova}
coint.lm %>%
  anova() %>%
  tidy() %>%  
  kable(caption = "Análise de Variacao") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

```{r resCoef}
coint.lm %>% 
  tidy() %>%  
  kable(caption = "Coeficientes da Regressao") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

tstat <- coint.lm %>% tidy %>% filter(term=="deltaRes") %>% pull(statistic)
```

Desta vez, o `t-stat` obtido foi de **`r round(tstat,3)`**, muito além (em módulo) dos valores para a tabela de significância para 500 ou mais amostras (**-2.87**). Neste caso confirmando que a hipótese de que a série é estacionária, e portanto os pares estão cointegrados.

## Trading Long-Short

### Spread

O gráfico abaixo apresenta a evolução do spread ao longo do tempo, com duas bandas representando -2 e 2 vezes o desvio padrão dos resíduos. Vemos que, apesar de os resíduos apresentarem certa persistência, comportam-se de maneira aparentemente desejável: flutuam razoavelmente ao redor da média, visitando-a com certa frequência. 

```{r spreadPlot}
# plot

# banda +/- 2 SD
sd.res <- sd(coint.ds$residuals)

# residuos e banda
coint.ds %>% 
  ggplot(aes(x=ref.date, y=residuals)) + 
  geom_line(color="blue",size=1) +
  geom_hline(yintercept =  2*sd.res, color="red", linetype=2) +
  geom_hline(yintercept = -2*sd.res, color="red", linetype=2) +
  theme_light()
```

Uma regra possível de operação consistiria em vender o par quando o resíduo estiver acima da banda, e comprar o par quando estiver abaixo da banda. O trade pode ser encerrado quando o par voltar a média ou a um percentual qualquer da média.

### Detectando Operações

Seguindo a estratégia acima, usamos as transições de banda e pela média para detectar os pontos de entrada e saída de operações long e short.

```{r startOperations}

startPar <- 2*sd.res
closePar <- 0

coint.ds %>% 
  mutate(operation=case_when(
    lagRes < startPar & residuals >= startPar   ~ "short_start",
    lagRes > closePar & residuals <= closePar    ~ "short_stop"
  )) %>%
  filter( !is.na(operation) ) %>% 
  mutate( operation.lag = lag(operation,1) ) %>% 
  select( ref.date, residuals, lagRes, operation, operation.lag ) %>% 
  filter( operation!=operation.lag ) %>% 
  select( -operation.lag) -> ops.short


coint.ds %>% 
  mutate(operation=case_when(
    lagRes > -startPar & residuals <= -startPar ~ "long_start",
    lagRes < -closePar & residuals >= -closePar ~ "long_stop"
  )) %>%
  filter( !is.na(operation) ) %>% 
  mutate( operation.lag = lag(operation,1) ) %>% 
  select( ref.date, residuals, lagRes, operation, operation.lag ) %>% 
  filter( operation!=operation.lag ) %>% 
  select( -operation.lag) -> ops.long

operations <- bind_rows(ops.short, ops.long)


# residuos e banda
coint.ds %>% 
  ggplot(aes(x=ref.date, y=residuals)) + 
  geom_line(color="blue",size=1, alpha=0.3) +
  geom_hline(yintercept =  startPar, color="red", linetype=2, alpha=0.5) +
  geom_hline(yintercept =  closePar, color="blue", linetype=2, alpha=0.5) +
  geom_hline(yintercept = -closePar, color="blue", linetype=2, alpha=0.5) +
  geom_hline(yintercept = -startPar, color="red", linetype=2, alpha=0.5) +
  geom_vline(data=operations, 
             mapping=aes(xintercept = ref.date, color=operation),
             size=1, linetype=1) +
  theme_light() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
```


### Referências

1. Moura, Guilherme V. e Caldeira, João F. - **Seleção de uma Carteira de Pares de Ações Usando Cointegração: Uma Estrategia de Arbitragem Estatística** - https://www.scribd.com/document/237462625/4785-19806-1-PB
1. Caldeira, João F. - **Arbitragem Estatística, Estratégia Long-Short Pairs Trading, Abordagem com Cointegração Aplicada ao Mercado de Ações Brasileiro** - http://www.anpec.org.br/revista/vol14/vol14n1p521_546.pdf
1. [Blog do Dr. Nickel](https://drnickel.wordpress.com/) - **Long-Short através de Cointegração** – [Parte 1](https://drnickel.wordpress.com/2015/03/15/long-short-atraves-de-cointegracao-parte-1/), [Parte 2](https://drnickel.wordpress.com/2015/03/15/long-short-atraves-de-cointegracao-parte-2/), [Parte 3](https://drnickel.wordpress.com/2015/04/03/long-short-atraves-de-cointegracao-parte-3/) e [Parte 4](https://drnickel.wordpress.com/2016/11/05/long-short-atraves-de-cointegracao-parte-4/)